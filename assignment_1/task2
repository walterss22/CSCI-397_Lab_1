My approach to this problem was to calculate the frequency of each letter in the ciphertext, match that with the English
language frequency table, then map the changes to the ciphertext. This was more difficult than i anticipated, but I was
greatly assisted by the newly ordered dictionaries as of Python 3.6. Originally, my thought was to try and match up the cipher
with the table by comparing frequencies, but it became clear early on that this approach was not feasible. It made much more 
sense to map the most frequent cipher with the most frequent in the table and go down the list from there. Once I had the letters 
mapped, the "plaintext" stilllooked incredibly ciphered. So I decided to look at the smallest words, one to two letters to try 
and see if I could figure them out. I started by looking at the letters adjacent to those being used and seeing if I could 
make english words out of them. This got me off to a great start. Then I moved on to looking at patterns of words, like 
verbs that end in -ing,repeated vowels, and things like that. Then I looked at words that were almost complete, but still 
not quite right. This strategy got me most of the way to the finish line. Once I could get the basic message of the text, it was 
pretty easy to make the remaining replacements (althought I did have to look up what a clif kid "jbar" was). 

Source for table: Wiki - https://en.wikipedia.org/wiki/Letter_frequency